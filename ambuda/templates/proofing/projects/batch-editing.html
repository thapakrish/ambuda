{% extends 'proofing/base.html' %}
{% import "macros/components.html" as components %}
{% import "macros/proofing.html" as m %}

{% macro help_item(code, desc) -%}
<div><code class="bg-slate-200 px-1 rounded">{{ code }}</code> - {{ desc }}</div>
{%- endmacro %}

{% macro dropdown_menu(items, button_class="") -%}
<div class="absolute right-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-20 min-w-[180px]">
  {% for item in items %}
  <button @click.prevent="{{ item.action }}; {{ item.close_var }} = false"
          :disabled="isSubmitting"
          class="w-full text-left px-3 py-2 text-xs hover:bg-slate-100{{ ' border-b border-slate-200' if not loop.last and loop.index == 1 else '' }}">
    {{ item.label }}
  </button>
  {% endfor %}
</div>
{%- endmacro %}

{% macro field_input(label, model, placeholder="", type="text", extra_class="") -%}
<div class="flex items-center gap-0.5">
  <span class="text-slate-400 text-[11px]">{{ label }}=</span>
  <input type="{{ type }}" x-model="{{ model }}"
         class="border border-slate-300 bg-transparent text-xs text-slate-600 {{ extra_class }} px-1 py-0 hover:bg-slate-100 rounded"
         placeholder="{{ placeholder }}">
</div>
{%- endmacro %}

{% macro preview_column(title, color, item_prefix) -%}
<div>
  <div class="font-medium text-{{ color }}-700 mb-1">{{ title }}:</div>
  <div class="bg-{{ color }}-50 border border-{{ color }}-200 rounded p-2">
    <div x-show="item.changes.type"><strong>type:</strong> <span x-text="item.changes.type?.{{ item_prefix }}"></span></div>
    <div x-show="item.changes.text"><strong>text:</strong> <span x-text="item.changes.text?.{{ item_prefix }}"></span></div>
    <div x-show="item.changes.mark"><strong>mark:</strong> <span x-text="item.changes.mark?.{{ item_prefix }}"></span></div>
    <div x-show="item.changes.content" class="font-mono" x-text="item.changes.content?.{{ item_prefix }}"></div>
  </div>
</div>
{%- endmacro %}

{% block title %}Batch Edit: {{ project.display_title }} | Ambuda{% endblock %}


{% block main %}
<div class="mt-8 px-4">
{{ components.flash_messages() }}

{{ m.project_header_nested('Batch Edit', project) }}
{{ m.project_tabs(project=project, active='edit') }}

{% set total_pages = project.pages|length %}
{% set pages_count = pages_with_content|length %}
{% if total_pages > pages_count %}
<div class="bg-blue-50 border border-blue-300 text-blue-800 px-4 py-3 rounded mb-4">
  <strong>Note:</strong> {{ total_pages - pages_count }} page(s) have been hidden because they have no content.
  Pages must be have text content before they can appear in the batch editing interface.
</div>
{% endif %}

<div x-data="batchEdit()" class="max-w-none">
  <div class="sticky top-0 z-10 bg-white border-b-2 border-slate-300 shadow-md mb-4">
    <div class="bg-slate-100 p-3">
      <div class="flex justify-between items-start mb-3">
        <div class="flex items-center gap-3">
          <h3 class="font-bold text-sm">Bulk Tools</h3>
          <div class="relative" @click.away="helpOpen = false">
            <button @click="helpOpen = !helpOpen"
                    class="text-xs px-2 py-1 border border-slate-400 rounded hover:bg-slate-200 text-slate-600">
              ? Help
            </button>
            <div x-show="helpOpen" x-transition
                 class="absolute left-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-20 w-96 p-3 text-xs">
              <h4 class="font-semibold mb-2">Select blocks syntax:</h4>
              <div class="space-y-1 mb-3 text-slate-700">
                {{ help_item('lang:sa', 'language is Sanskrit') }}
                {{ help_item('type:paragraph', 'block type') }}
                {{ help_item('text:MyText', 'text field equals') }}
                {{ help_item('regex:[0-9]+', 'regex match content') }}
                {{ help_item('contains:foo', 'substring in content') }}
                {{ help_item('lang:sa type:paragraph', 'AND (space)') }}
                {{ help_item('lang:sa OR lang:en', 'OR') }}
                {{ help_item('NOT type:ignore', 'NOT') }}
              </div>
              <h4 class="font-semibold mb-2">Change blocks syntax:</h4>
              <div class="space-y-1 text-slate-700">
                {{ help_item('text="MyText"', 'set text field') }}
                {{ help_item('text=""', 'clear text field') }}
                {{ help_item('type=paragraph', 'set block type') }}
                {{ help_item('type=ignore', 'ignore block') }}
                {{ help_item('mark="*"', 'set footnote mark') }}
                {{ help_item('replace="pattern" with="replacement"', 'regex replace') }}
              </div>
            </div>
          </div>
        </div>

        <div class="flex gap-3 items-center">
          <div class="text-xs text-slate-600">
            <span x-text="pageRangeText()"></span>
          </div>
          <div class="flex gap-1">
            <button @click="prevPage()" :disabled="currentPage === 1"
                    class="px-2 py-1 border rounded text-xs disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-200">
              ← Prev
            </button>
            <button @click="nextPage()" :disabled="currentPage === totalPages()"
                    class="px-2 py-1 border rounded text-xs disabled:opacity-50 disabled:cursor-not-allowed hover:bg-slate-200">
              Next →
            </button>
          </div>
          <div class="border-l border-slate-400 h-6"></div>
          <button @click.prevent="previewStructure()" type="button" class="btn btn-basic text-xs px-3 py-1">
            Preview JSON
          </button>
          <div class="relative" @click.away="saveMenuOpen = false">
            <button @click="saveMenuOpen = !saveMenuOpen"
                    :disabled="isSubmitting"
                    class="btn btn-submit text-xs px-3 py-1 flex items-center gap-1"
                    :class="{ 'opacity-50 cursor-not-allowed': isSubmitting }">
              Save
              <span class="text-[10px]">▼</span>
            </button>
            <div x-show="saveMenuOpen"
                 x-transition
                 class="absolute right-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-20 min-w-[180px]">
              <button @click.prevent="submitStructure(); saveMenuOpen = false"
                      :disabled="isSubmitting"
                      class="w-full text-left px-3 py-2 text-xs hover:bg-slate-100 border-b border-slate-200">
                Structure all pages
              </button>
              <button @click.prevent="submitChangedOnly(); saveMenuOpen = false"
                      :disabled="isSubmitting"
                      class="w-full text-left px-3 py-2 text-xs hover:bg-slate-100">
                Save changes only
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="grid grid-cols-2 gap-3 mb-3">
        <div>
          <label class="block text-xs font-medium mb-1">Select blocks:</label>
          <input type="text"
                 x-model="selectCommand"
                 placeholder='e.g., lang:sa type:paragraph'
                 class="w-full border rounded px-2 py-1 text-xs font-mono">
        </div>
        <div>
          <label class="block text-xs font-medium mb-1">Change blocks:</label>
          <input type="text"
                 x-model="changeCommand"
                 placeholder='e.g., text="MyText"'
                 class="w-full border rounded px-2 py-1 text-xs font-mono">
        </div>
      </div>

      <div class="flex justify-between items-center mb-2">
        <div class="flex gap-2 items-center flex-wrap">
          <button @click="applyBulkCommand()" class="btn btn-submit text-xs px-3 py-1">Apply</button>
          <button @click="clearBulkCommands()" class="btn btn-basic text-xs px-3 py-1">Clear</button>
          <label x-show="replaceMode" class="flex items-center gap-1">
            <input type="checkbox" x-model="replaceGlobal" class="w-3 h-3">
            <span class="text-xs">Global</span>
          </label>
          <label x-show="replaceMode" class="flex items-center gap-1">
            <input type="checkbox" x-model="replaceCaseInsensitive" class="w-3 h-3">
            <span class="text-xs">Case-insensitive</span>
          </label>
        </div>

        <span x-show="structureStatus"
              x-text="structureStatus"
              class="text-xs"
              :class="statusSuccess ? 'text-green-600' : 'text-slate-600'"></span>
      </div>

      <p x-show="bulkCommandStatus" x-text="bulkCommandStatus" class="text-xs text-slate-700"></p>
    </div>

    <div x-show="changePreview.length > 0" class="bg-white border-t border-amber-300 p-3 max-h-96 overflow-y-auto">
      <div class="flex justify-between items-center mb-2 sticky top-0 bg-white pb-2 border-b border-amber-200">
        <h5 class="font-semibold text-sm text-amber-900">Preview: <span x-text="changePreview.length"></span> block(s) will be changed</h5>
        <div class="flex gap-2">
          <button @click="confirmPreview()" class="btn btn-submit text-xs bg-amber-600 hover:bg-amber-700">Confirm & Apply</button>
          <button @click="cancelPreview()" class="btn btn-basic text-xs">Cancel</button>
        </div>
      </div>
      <template x-for="(item, idx) in changePreview" :key="idx">
        <div class="mb-3 pb-3 border-b border-slate-200 last:border-b-0">
          <div class="text-xs text-slate-500 mb-1">
            Page <span x-text="item.pageSlug"></span>, Block <span x-text="item.blockIndex"></span>
          </div>
          <div class="grid grid-cols-2 gap-2 text-xs">
            {{ preview_column('Before', 'red', 'before') }}
            {{ preview_column('After', 'green', 'after') }}
          </div>
        </div>
      </template>
    </div>
  </div>

  <template x-for="item in paginatedPages()" :key="item.slug">
    <div class="border-t border-slate-200 mt-4 pt-2">
      <div class="flex items-center gap-2 mb-2">
        <a :href="'{{ url_for('proofing.page.edit', project_slug=project.slug, page_slug='') }}' + item.slug"
           target="_blank"
           class="text-xs font-medium text-slate-400 hover:text-blue-600 hover:underline"
           x-text="'Page ' + item.slug"></a>
        <label class="flex items-center gap-1 cursor-pointer hover:bg-slate-100 px-1 py-0.5 rounded">
          <input type="checkbox"
                 x-model="item.ignorePage"
                 class="w-3 h-3">
          <span class="text-xs text-slate-500">Ignore page</span>
        </label>
        <button @click="toggleImageViewer(item.slug)"
                class="text-xs px-2 py-0.5 border rounded hover:bg-slate-100"
                :class="imageViewerPage === item.slug ? 'bg-blue-100 border-blue-400' : 'border-slate-300'">
          <span x-show="imageViewerPage !== item.slug">Show image</span>
          <span x-show="imageViewerPage === item.slug">Hide image</span>
        </button>
      </div>

      <div class="flex gap-4">
        <div :class="imageViewerPage === item.slug ? 'w-1/2' : 'w-full'" class="transition-all">
          <div class="space-y-3" x-show="!item.ignorePage">
        <template x-for="(block, index) in item.blocks" :key="index">
          <div x-show="filterText === '' || (block.text || '') === filterText"
               class="border-l-4 pl-4 transition-colors"
               :class="[blockTypeColors[block.type] || 'border-gray-400', block.merge_next && 'bg-yellow-50 !border-dashed']">
            <div class="flex gap-1 mb-1 px-1.5 py-1 text-xs text-slate-500 items-center bg-slate-50 rounded leading-tight">
              {# block tag #}
              <select x-model="block.type"
                      class="border border-slate-300 bg-white text-xs font-medium cursor-pointer hover:bg-slate-100 rounded px-1 py-0"
                      @change="updateNumbering">
                {% for block_type in block_types %}
                <option value="{{ block_type.tag }}">{{ block_type.label }}</option>
                {% endfor %}
              </select>

              <div class="flex items-center gap-0.5">
                <span class="text-slate-400 text-[11px]">text=</span>
                <input type="text"
                       x-model="block.text"
                       :list="'text-list-' + item.slug"
                       @change="updateNumbering"
                       class="border border-slate-300 bg-transparent text-xs text-slate-600 w-20 px-1 py-0 hover:bg-slate-100 rounded"
                       placeholder="text">
                <datalist :id="'text-list-' + item.slug">
                  <template x-for="textName in getUniqueTexts(item)" :key="textName">
                    <option :value="textName"></option>
                  </template>
                </datalist>
              </div>

              <template x-if="block.type === 'footnote'">
                <div class="flex items-center gap-0.5">
                  <span class="text-slate-400 text-[11px]">mark=</span>
                  <input type="text"
                         x-model="block.mark"
                         class="border border-slate-300 bg-transparent font-mono text-xs text-slate-600 w-16 px-1 py-0 hover:bg-slate-100 rounded"
                         placeholder="mark">
                </div>
              </template>

              <template x-if="block.type !== 'footnote'">
                <div class="flex items-center gap-0.5">
                  <span class="text-slate-400 text-[11px]">n=</span>
                  <input type="text"
                         x-model="block.n"
                         @change="block.manualNumber = true; propagateNumbering(item, index)"
                         :class="block.manualNumber ?
                           'border border-slate-300 bg-amber-200 font-mono text-xs text-slate-800 w-12 px-1 py-0 hover:bg-amber-300 rounded' :
                           'border border-slate-300 bg-transparent font-mono text-xs text-slate-600 w-12 px-1 py-0 hover:bg-slate-100 rounded'"
                         placeholder="#">
                </div>
              </template>

              <div class="flex items-center gap-0.5">
                <span class="text-slate-400 text-[11px]">detected_lang=</span>
                <span class="text-xs text-slate-600" x-text="block.lang || ''"></span>
              </div>

              <label class="flex items-center gap-0.5 cursor-pointer hover:bg-slate-100 px-1 rounded">
                <input type="checkbox"
                       x-model="block.merge_next"
                       @change="updateNumbering"
                       class="w-3 h-3">
                <span class="text-[11px]">merge</span>
              </label>

              <div class="ml-auto relative" @click.away="openDropdown = null">
                <button @click="openDropdown = (openDropdown === `${item.slug}-${index}` ? null : `${item.slug}-${index}`)"
                        type="button"
                        class="text-[11px] px-2 py-0.5 bg-slate-200 hover:bg-slate-300 rounded border border-slate-400"
                        title="Block actions">
                  ⋯
                </button>
                <div x-show="openDropdown === `${item.slug}-${index}`"
                     x-transition
                     class="absolute right-0 mt-1 bg-white border border-slate-300 rounded shadow-lg z-10 min-w-[140px]">
                  <button @click="addBlockBelow(item, index); openDropdown = null"
                          type="button"
                          class="w-full text-left px-3 py-2 text-xs hover:bg-slate-100 flex items-center gap-2">
                    <span class="text-green-600">+</span> Add below
                  </button>
                  <button @click="restructureBlock(item, index); openDropdown = null"
                          type="button"
                          class="w-full text-left px-3 py-2 text-xs hover:bg-slate-100 flex items-center gap-2 border-t border-slate-200">
                    <span class="text-blue-600">↻</span> Re-structure
                  </button>
                  <button @click="removeBlock(item, index); openDropdown = null"
                          type="button"
                          class="w-full text-left px-3 py-2 text-xs hover:bg-red-50 text-red-700 flex items-center gap-2 border-t border-slate-200">
                    <span>×</span> Remove
                  </button>
                </div>
              </div>
            </div>
            <div class="relative">
              <textarea x-model="block.content"
                        @input="onContentChange(block)"
                        :class="block.contentChanged ?
                          'w-full text-base p-2 border-2 border-red-300 bg-red-50 rounded font-normal resize-y min-h-[3rem]' :
                          'w-full text-base p-2 border border-slate-200 bg-white rounded font-normal resize-y min-h-[3rem]'"
                        :rows="block.content.split('\n').length"></textarea>
              <button x-show="block.contentChanged"
                      @click="resetContent(block)"
                      class="absolute top-2 right-2 px-2 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600 transition-colors">
                Reset
              </button>
            </div>
          </div>
        </template>
          </div>
        </div>

        <div x-show="imageViewerPage === item.slug"
             x-transition
             class="w-1/2">
          <div class="bg-slate-100 border border-slate-300 rounded sticky top-[180px]">
            <div class="bg-slate-200 px-3 py-2 border-b border-slate-300 flex justify-between items-center">
              <h4 class="text-xs font-medium">
                Page <span x-text="item.slug"></span>
              </h4>
              <button @click="toggleImageViewer(null)"
                      class="text-xs px-2 py-1 hover:bg-slate-300 rounded">
                ✕
              </button>
            </div>
            <div :id="'osd-viewer-' + item.slug" class="bg-white" style="height: 600px;"></div>
          </div>
        </div>
      </div>
    </div>
  </template>

  <form method="POST" action="{{ url_for('proofing.project.batch_editing', slug=project.slug) }}">
    <input type="hidden" name="structure_data" x-ref="structureData">
  </form>

  <div x-show="structureJson" class="mt-4 bg-slate-50 rounded border border-slate-200 p-4">
    <div class="flex justify-between items-center mb-2">
      <h4 class="font-bold text-sm">Generated Structure (JSON)</h4>
      <button @click="copyToClipboard()" type="button" class="btn btn-basic text-xs">Copy to clipboard</button>
    </div>
    <pre class="text-xs overflow-auto max-h-96 p-3 rounded border border-slate-300"
         x-text="structureJson"></pre>
  </div>
</div>

<script>
function batchEdit() {
  return {
    pages: {{ pages_with_content|tojson }},
    currentPage: 1,
    pagesPerPage: 50,
    imageViewerPage: null,
    osdViewer: null,
    helpOpen: false,

    init() {
      this.pages.forEach(page => {
        page.ignorePage = false;
        page.blocks.forEach((block, index) => {
          this.initializeBlock(block, index);
        });
      });
      this.updateNumbering();
    },

    selectCommand: '',
    changeCommand: '',
    bulkCommandStatus: '',
    filterText: '',
    structureJson: '',
    structureStatus: '',
    statusSuccess: false,
    isSubmitting: false,

    replaceMode: false,
    replaceGlobal: true,
    replaceCaseInsensitive: false,
    changePreview: [],
    pendingChangeTokens: null,
    pendingSelectTokens: null,
    openDropdown: null,
    saveMenuOpen: false,
    numberingTimeout: null,

    blockTypeColors: {
      'p': 'border-blue-400',
      'verse': 'border-purple-400',
      'heading': 'border-orange-400',
      'title': 'border-indigo-400',
      'subtitle': 'border-pink-400',
      'footnote': 'border-green-400',
      'trailer': 'border-teal-400',
      'ignore': 'border-gray-300'
    },

    initializeBlock(block, index) {
      if (block.type === 'footnote' && !block.mark) block.mark = '';

      Object.assign(block, {
        originalContent: block.content,
        originalType: block.type,
        originalText: block.text || '',
        originalMark: block.mark || '',
        originalMergeNext: block.merge_next || false,
        originalN: block.n || '',
        contentChanged: false,
        manualNumber: !!block.n,
        originalIndex: index
      });
    },

    createBlock(overrides = {}) {
      return Object.assign({
        type: 'p',
        content: '',
        text: '',
        n: null,
        mark: '',
        lang: null,
        merge_next: false,
        originalContent: '',
        originalType: 'p',
        originalText: '',
        originalMark: '',
        originalMergeNext: false,
        originalN: '',
        contentChanged: false,
        manualNumber: false,
        originalIndex: null
      }, overrides);
    },

    blockToData(block, includeAllNumbers = false) {
      const data = {
        type: block.type,
        text: block.text || null,
        merge_next: block.merge_next || false,
        n: (includeAllNumbers || block.manualNumber) ? (block.n || null) : null,
        mark: block.mark || null,
        index: block.originalIndex
      };

      if (block.originalIndex === null || block.contentChanged) {
        data.content = block.content;
      }

      return data;
    },

    onContentChange(block) {
      block.contentChanged = block.content !== block.originalContent;
    },

    resetContent(block) {
      block.content = block.originalContent;
      block.contentChanged = false;
    },

    paginatedPages() {
      const start = (this.currentPage - 1) * this.pagesPerPage;
      const end = start + this.pagesPerPage;
      return this.pages.slice(start, end);
    },

    totalPages() {
      return Math.ceil(this.pages.length / this.pagesPerPage);
    },

    pageRangeText() {
      const paginated = this.paginatedPages();
      if (paginated.length === 0) return 'No pages';
      if (paginated.length === 1) return `Page ${paginated[0].slug}`;
      return `Page ${paginated[0].slug} to ${paginated[paginated.length - 1].slug}`;
    },

    nextPage() {
      if (this.currentPage < this.totalPages()) {
        this.currentPage++;
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    },

    prevPage() {
      if (this.currentPage > 1) {
        this.currentPage--;
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    },

    toggleImageViewer(pageSlug) {
      if (this.imageViewerPage === pageSlug) {
        this.imageViewerPage = null;
        if (this.osdViewer) {
          this.osdViewer.destroy();
          this.osdViewer = null;
        }
      } else {
        this.imageViewerPage = pageSlug;
        this.$nextTick(() => {
          this.initializeOSD(pageSlug);
        });
      }
    },

    initializeOSD(pageSlug) {
      const imageUrl = '{{ url_for("site.page_image", project_slug=project.slug, page_slug="PAGE_SLUG") }}'.replace('PAGE_SLUG', pageSlug);
      const viewerId = 'osd-viewer-' + pageSlug;

      if (this.osdViewer) {
        this.osdViewer.destroy();
      }

      this.osdViewer = OpenSeadragon({
        id: viewerId,
        tileSources: {
          type: 'image',
          url: imageUrl,
          buildPyramid: false,
        },
        showNavigationControl: false,
        showZoomControl: false,
        showHomeControl: false,
        showFullPageControl: false,
        showRotationControl: false,
        gestureSettingsMouse: {
          flickEnabled: true,
        },
        animationTime: 0.5,
        zoomPerClick: 1.2,
        maxZoomPixelRatio: 2.5,
      });
    },

    parseValue(str, pos) {
      if (str[pos] !== '"') {
        const end = str.indexOf(' ', pos);
        return { value: str.substring(pos, end === -1 ? str.length : end), endPos: end === -1 ? str.length : end };
      }

      let value = '', i = pos + 1;
      while (i < str.length) {
        if (str[i] === '\\' && i + 1 < str.length) {
          value += str[i + 1];
          i += 2;
        } else if (str[i] === '"') {
          return { value, endPos: i + 1 };
        } else {
          value += str[i++];
        }
      }
      throw new Error('Unterminated string');
    },

    tokenizeCommand(command) {
      const tokens = [];
      let i = 0;

      while (i < command.length) {
        while (command[i] === ' ') i++;
        if (i >= command.length) break;

        const remaining = command.substring(i);
        if (remaining.startsWith('OR')) {
          tokens.push({ type: 'OR' });
          i += 2;
        } else if (remaining.startsWith('NOT')) {
          tokens.push({ type: 'NOT' });
          i += 3;
        } else {
          const opIdx = remaining.search(/[:=]/);
          if (opIdx === -1) throw new Error(`Invalid predicate at position ${i}`);

          const key = remaining.substring(0, opIdx);
          const op = remaining[opIdx];
          const { value, endPos } = this.parseValue(command, i + opIdx + 1);

          tokens.push({ type: 'PRED', key, op, value });
          i = endPos;
        }
      }
      return tokens;
    },

    evalPredicate(pred, block) {
      const predicates = {
        lang: () => block.lang === pred.value,
        type: () => block.type === pred.value,
        text: () => (block.text || '') === pred.value,
        regex: () => {
          try {
            return new RegExp(pred.value).test(block.content);
          } catch (e) {
            throw new Error(`Invalid regex: ${pred.value}`);
          }
        },
        contains: () => (block.content || '').includes(pred.value)
      };

      const fn = predicates[pred.key];
      if (!fn) throw new Error(`Unknown predicate: ${pred.key}`);
      return fn();
    },

    evalSelection(tokens, block) {
      if (tokens.length === 0) return true;

      let result = null;
      let expectingOperand = true;
      let negate = false;

      for (const token of tokens) {
        if (token.type === 'OR') {
          if (expectingOperand) throw new Error('Unexpected OR');
          expectingOperand = true;
        } else if (token.type === 'NOT') {
          if (!expectingOperand) throw new Error('Unexpected NOT');
          negate = true;
        } else if (token.type === 'PRED') {
          if (!expectingOperand) {
            // Implicit AND
            if (result !== null) {
              let predResult = this.evalPredicate(token, block);
              if (negate) predResult = !predResult;
              result = result && predResult;
              negate = false;
            } else {
              result = this.evalPredicate(token, block);
              if (negate) result = !result;
              negate = false;
            }
          } else {
            // After OR or at start
            let predResult = this.evalPredicate(token, block);
            if (negate) predResult = !predResult;
            if (result === null) {
              result = predResult;
            } else {
              result = result || predResult;
            }
            negate = false;
            expectingOperand = false;
          }
        }
      }

      return result !== null ? result : true;
    },

    applyChange(tokens, block) {
      for (const token of tokens) {
        if (token.type !== 'PRED' || token.op !== '=') {
          throw new Error('Change command must use key=value format');
        }

        switch (token.key) {
          case 'text':
            block.text = token.value;
            break;
          case 'type':
            block.type = token.value;
            break;
          case 'mark':
            if (block.type === 'footnote') {
              block.mark = token.value;
            }
            break;
          case 'replace':
          case 'with':
            // These are handled separately in applyBulkCommand
            break;
          default:
            throw new Error(`Unknown change key: ${token.key}`);
        }
      }
    },

    extractReplaceCommand(tokens) {
      let replacePattern = null;
      let replaceWith = null;
      const otherTokens = [];

      for (const token of tokens) {
        if (token.type === 'PRED' && token.key === 'replace') {
          replacePattern = token.value;
        } else if (token.type === 'PRED' && token.key === 'with') {
          replaceWith = token.value;
        } else {
          otherTokens.push(token);
        }
      }

      return { replacePattern, replaceWith, otherTokens };
    },

    applyBulkCommand() {
      try {
        const selectTokens = this.selectCommand.trim() ? this.tokenizeCommand(this.selectCommand.trim()) : [];
        const changeTokens = this.changeCommand.trim() ? this.tokenizeCommand(this.changeCommand.trim()) : [];

        if (selectTokens.length === 0 && changeTokens.length === 0) {
          this.bulkCommandStatus = 'Please enter a selection or change command';
          return;
        }

        if (changeTokens.length === 0) {
          let matchCount = 0;
          this.pages.forEach(page => {
            page.blocks.forEach(block => {
              if (this.evalSelection(selectTokens, block)) {
                matchCount++;
              }
            });
          });
          this.bulkCommandStatus = `Matched ${matchCount} blocks`;
          return;
        }

        this.previewBulkChanges(selectTokens, changeTokens);
      } catch (e) {
        this.bulkCommandStatus = `Error: ${e.message}`;
      }
    },

    previewBulkChanges(selectTokens, changeTokens) {
      this.changePreview = [];
      this.bulkCommandStatus = '';
      this.pendingChangeTokens = changeTokens;
      this.pendingSelectTokens = selectTokens;

      const { replacePattern, replaceWith, otherTokens } = this.extractReplaceCommand(changeTokens);

      try {
        let matchCount = 0;

        this.pages.forEach(page => {
          page.blocks.forEach((block, blockIndex) => {
            const matches = this.evalSelection(selectTokens, block);
            if (!matches) return;

            const changes = {};
            let hasChanges = false;

            if (replacePattern !== null) {
              if (!block.content) return;
              const flags = (this.replaceGlobal ? 'g' : '') + (this.replaceCaseInsensitive ? 'i' : '');
              const regex = new RegExp(replacePattern, flags);
              const newContent = block.content.replace(regex, replaceWith || '');

              if (newContent !== block.content) {
                changes.content = { before: block.content, after: newContent };
                hasChanges = true;
              }
            }

            const tempBlock = { ...block };
            otherTokens.forEach(token => {
              if (token.type !== 'PRED' || token.op !== '=') return;

              switch (token.key) {
                case 'text':
                  if (block.text !== token.value) {
                    changes.text = { before: block.text || '', after: token.value };
                    hasChanges = true;
                  }
                  break;
                case 'type':
                  if (block.type !== token.value) {
                    changes.type = { before: block.type, after: token.value };
                    hasChanges = true;
                  }
                  break;
                case 'mark':
                  if (block.type === 'footnote' && block.mark !== token.value) {
                    changes.mark = { before: block.mark || '', after: token.value };
                    hasChanges = true;
                  }
                  break;
              }
            });

            if (hasChanges) {
              this.changePreview.push({
                pageSlug: page.slug,
                blockIndex: blockIndex,
                type: block.type,
                changes: changes,
                page: page,
                block: block
              });
              matchCount++;
            }
          });
        });

        if (matchCount === 0) {
          this.bulkCommandStatus = 'No changes would be made';
        } else {
          this.bulkCommandStatus = `Found ${matchCount} block(s) to change. Review and confirm.`;
          this.replaceMode = true;
        }
      } catch (e) {
        this.bulkCommandStatus = `Error: ${e.message}`;
      }
    },

    confirmPreview() {
      if (this.changePreview.length === 0) return;

      this.changePreview.forEach(item => {
        if (item.changes.content) {
          item.block.content = item.changes.content.after;
          item.block.contentChanged = item.block.content !== item.block.originalContent;
        }
        if (item.changes.type) {
          item.block.type = item.changes.type.after;
        }
        if (item.changes.text) {
          item.block.text = item.changes.text.after;
        }
        if (item.changes.mark) {
          item.block.mark = item.changes.mark.after;
        }
      });

      const count = this.changePreview.length;
      this.bulkCommandStatus = `Applied changes to ${count} block(s)`;
      this.changePreview = [];
      this.replaceMode = false;
      this.pendingChangeTokens = null;
      this.pendingSelectTokens = null;

      this.updateNumbering();

      setTimeout(() => {
        this.bulkCommandStatus = '';
      }, 3000);
    },

    cancelPreview() {
      this.changePreview = [];
      this.replaceMode = false;
      this.pendingChangeTokens = null;
      this.pendingSelectTokens = null;
      this.bulkCommandStatus = 'Changes cancelled';
      setTimeout(() => {
        this.bulkCommandStatus = '';
      }, 2000);
    },

    clearBulkCommands() {
      this.selectCommand = '';
      this.changeCommand = '';
      this.bulkCommandStatus = '';
      this.changePreview = [];
      this.replaceMode = false;
      this.pendingChangeTokens = null;
      this.pendingSelectTokens = null;
    },

    addBlockBelow(page, blockIndex) {
      page.blocks.splice(blockIndex + 1, 0, this.createBlock());
      this.updateNumbering();
    },

    removeBlock(page, blockIndex) {
      if (page.blocks.length === 1) {
        alert('Cannot remove the last block on a page');
        return;
      }

      if (confirm('Are you sure you want to remove this block?')) {
        page.blocks.splice(blockIndex, 1);
        this.updateNumbering();
      }
    },

    async restructureBlock(page, blockIndex) {
      const block = page.blocks[blockIndex];
      const content = block.content;

      if (!content || content.trim() === '') {
        alert('Block is empty, nothing to restructure');
        return;
      }

      try {
        const csrfToken = document.querySelector('input[name="csrf_token"]')?.value;
        const response = await fetch('{{ url_for("proofing.project.parse_content", slug=project.slug) }}', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrfToken,
          },
          body: JSON.stringify({ content: content })
        });

        if (!response.ok) {
          throw new Error('Failed to parse content');
        }

        const data = await response.json();

        if (!data.blocks || data.blocks.length === 0) {
          alert('No blocks found after parsing');
          return;
        }

        const newBlocks = data.blocks.map(blockData => this.createBlock({
          type: blockData.type,
          content: blockData.content,
          text: block.text || '',
          mark: blockData.mark || '',
          lang: blockData.lang || null,
          originalContent: blockData.content,
          originalType: blockData.type,
          originalText: block.text || '',
          originalMark: blockData.mark || ''
        }));
        page.blocks.splice(blockIndex, 1, ...newBlocks);

        this.updateNumbering();
        alert(`Restructured into ${newBlocks.length} block(s)`);
      } catch (e) {
        alert(`Failed to restructure: ${e.message}`);
        console.error('Restructure error:', e);
      }
    },

    getUniqueTexts(page) {
      const texts = new Set();
      page.blocks.forEach(block => {
        if (block.text && block.text.trim() !== '') {
          texts.add(block.text.trim());
        }
      });
      return Array.from(texts).sort();
    },

    propagateNumbering(page, blockIndex) {
      const firstBlock = page.blocks[blockIndex];
      const pageIndex = this.pages.findIndex(p => p.slug === page.slug);
      if (pageIndex === -1) return;

      const match = firstBlock.n?.match(/^(.*?)(\d+)$/);
      if (!match) return;

      const [, prefix, startNum] = match;
      let next = parseInt(startNum);
      if (!firstBlock.merge_next) next += 1;

      const targetText = firstBlock.text;

      for (let i = pageIndex; i < this.pages.length; i++) {
        const currentPage = this.pages[i];
        const startIdx = i === pageIndex ? blockIndex + 1 : 0;

        for (let j = startIdx; j < currentPage.blocks.length; j++) {
          const block = currentPage.blocks[j];

          if (block.text !== targetText || !['verse', 'p'].includes(block.type)) continue;
          if (block.manualNumber) return;

          block.n = `${prefix}${next}`;
          if (!block.merge_next) next += 1;
        }
      }
    },

    updateNumbering() {
      clearTimeout(this.numberingTimeout);
      this.numberingTimeout = setTimeout(() => {
        // Clear automatic numbers
        this.pages.forEach(page => {
          page.blocks.forEach(block => {
            if (!block.manualNumber) block.n = null;
          });
        });

        // Propagate from manual numbers
        this.pages.forEach((page, i) => {
          page.blocks.forEach((block, j) => {
            if (block.manualNumber) {
              this.propagateNumbering(page, j);
            }
          });
        });
      }, 100);
    },

    generateStructure() {
      return {
        project: '{{ project.slug }}',
        pages: this.pages
          .filter(page => !page.ignorePage)
          .map(page => ({
            slug: page.slug,
            version: page.version,
            blocks: page.blocks.map(block => this.blockToData(block, true))
          }))
      };
    },

    previewStructure() {
      const structure = this.generateStructure();
      const includedPages = this.pages.filter(page => !page.ignorePage);
      const ignoredCount = this.pages.length - includedPages.length;

      this.structureJson = JSON.stringify(structure, null, 2);
      this.structureStatus = `Generated structure for ${includedPages.length} pages` +
        (ignoredCount > 0 ? ` (${ignoredCount} page${ignoredCount > 1 ? 's' : ''} ignored)` : '');
      this.statusSuccess = false;
    },

    copyToClipboard() {
      navigator.clipboard.writeText(this.structureJson).then(() => {
        this.structureStatus = 'Copied to clipboard!';
        setTimeout(() => {
          this.structureStatus = '';
        }, 2000);
      }).catch(err => {
        this.structureStatus = 'Failed to copy';
        console.error('Copy failed:', err);
      });
    },

    hasBlockChanged(block) {
      if (block.originalIndex === null) return true;

      const fields = [
        ['content', 'originalContent'],
        ['type', 'originalType'],
        ['text', 'originalText', ''],
        ['mark', 'originalMark', ''],
        ['merge_next', 'originalMergeNext', false]
      ];

      for (const [field, original, defaultVal = null] of fields) {
        if ((block[field] ?? defaultVal) !== block[original]) return true;
      }

      return block.manualNumber && (block.n || '') !== block.originalN;
    },

    pageHasChanges(page) {
      return page.blocks.some(block => this.hasBlockChanged(block));
    },

    submitChangedOnly() {
      if (this.isSubmitting) return;

      const pagesWithChanges = this.pages.filter(page =>
        !page.ignorePage && this.pageHasChanges(page)
      );

      if (pagesWithChanges.length === 0) {
        alert('No changes detected');
        return;
      }

      if (!confirm(`Save changes to ${pagesWithChanges.length} page(s)?`)) return;

      this.submitPages(pagesWithChanges, false);
    },

    submitPages(pages, includeAllNumbers) {
      this.isSubmitting = true;
      this.structureStatus = 'Preparing submission...';

      const structure = {
        project: '{{ project.slug }}',
        pages: pages.map(page => ({
          slug: page.slug,
          version: page.version,
          blocks: page.blocks.map(block => this.blockToData(block, includeAllNumbers))
        }))
      };

      this.$refs.structureData.value = JSON.stringify(structure);
      this.$el.closest('form').submit();
    },

    submitStructure() {
      if (this.isSubmitting) return;
      this.submitPages(this.pages.filter(page => !page.ignorePage), true);
    }
  };
}
</script>

<script src="https://cdn.jsdelivr.net/npm/openseadragon@3.1/build/openseadragon/openseadragon.min.js"></script>
</div>
{% endblock %}
